## INSERT

1. При вставке данных в таблицу track возникает ошибка. Используются айди, которые не определены в таблице альбомов. Это связано с тем, что не учли момент при котором из-за возникающих ошибок вставки данных смещается автоинкремент. Но если заново создать таблицы и попробовать вставить данные, то нумерация начнется с самого начала. Или тогда вам необходимо явно прописывать айди для каждой записи.

2. Аналогичная ошибка с айди возникает при вставке данных в промежуточные таблицы.

## SELECT

1. Данный запрос

-- 2.5 выведем название треков, которые содержат слово «мой» или «my».

SELECT title  from  track

WHERE 

    title LIKE '%Мой%' or

    title LIKE '%мой%' or 

    title LIKE '%My%' or 

    title LIKE '%my%'

;

необходимо немного доработать. В текущей реализации вы находите не слова, а лишь часть в строке, что является некорректным решением. Например, в выборку данных попадает название трека myself, которого не должно быть.
Обратите внимание, что запрос должен быть написан таким образом, чтобы для слова my следующие названия треков


my own

own my

my

oh my god


попадали в выборку.
### При этом треки с названиями

myself

by myself

bemy self

myself by

by myself by

beemy

premyne

## НЕ ДОЛЖНЫ ПОПАСТЬ В ИТОГОВЫЙ РЕЗУЛЬТАТ.
### Чтобы проверить корректность работы запроса, добавьте все эти названия в вашу таблицу треков
Запрос можно реализовать несколькими способами:
- ### Основной способ реализации на основе полученных знаний
1. С применением ILIKE (чтобы не зависеть от регистра), где в условии WHERE будет четыре проверки, объединенных между собой OR. При реализации условий, необходимо учитывать пробелы, т.к. слово может находится в разных частях строки.


    SELECT ... FROM ... /* Имя трека из таблицы треков */

    WHERE ... ILIKE '...' /* Где слово в начале строки */

    OR ... ILIKE '...' /* Где слово в конце строки */

    OR ... ILIKE '...' /* Где слово в середине строки */

    OR ... ILIKE '...'; /* Где название трека состоит из одного искомого слова */

### Обратите внимание, что четыре проверки только на один вариант искомого слова. Если два варианта, то это 8 проверок.

* ### Дополнительные необязательные способы реализации, которые не только расширят ваш кругозор, но и могут вам пригодиться в дальнейшем как показатель знаний разного функционала данной базы данных
    1. При помощи следующих инструментов... string_to_array, lower и &&. Архитектура и логика следующие...
SELECT ... FROM ... # Запрашиваем имена треков из таблицы треков
WHERE <функция_для разбития_строки>(<функция_нижнего_регистра>(<поле_название_трека>), <разделитель>) && ARRAY['...', и т.д.]... ; #Преобразуем название трека в нижний регистр, разбиваем строку на пробелы, получая массив (список) слов, и делаем пересечение с нужным массивом слов (используем `string_to_array`, `lower`). 
Т.е. в WHERE приведенное к нижнему регистру название трека разбиваем на пробелы (' '), получая массив (список) слов (по принципу метода split в python), и делаем пересечение (&&) с другим массивом слов(ARRAY). Используем string_to_array и lower. Ссылки на необходимые инструменты в официальной документации: Как работает функция string_to_array, которая разбивает строку по разделителю и возвращает массив из значений https://postgrespro.ru/docs/postgresql/14/functions-string Как работает пересечение && между двумя массивами https://postgrespro.ru/docs/postgresql/14/functions-array Как пишется массив(ARRAY) можно ознакомиться здесь. Имейте ввиду, что в массив можно передавать несколько значений. https://bestprogrammer.ru/baza-dannyh/massiv-postgresql-v-stroku
    2. При помощи соответствия сроки регулярному выражению без учета регистра ~*. Пример построения запроса
SELECT ... FROM ... /* Имена треков из таблицы треков*/
WHERE ... ~* '...'; /* Где имя трека соответствует шаблону */ 
Ознакомиться с оператором и информацией по оформлению шаблонов можно здесь https://postgrespro.ru/docs/postgresql/15/functions-matching#FUNCTIONS-POSIX-REGEXP. Обратите внимание на таблицу 9.22. В ней вы найдете инструменты для корректной реализации.


2. Данный запрос

-- 3.2 выведем количество треков, вошедших в альбомы 2019–2020 годов.

SELECT a.title, a.year, count(t.id) FROM album a

JOIN track t ON a.id = t.album_id

WHERE a.year >= 2019 AND a.year <= 2020

GROUP BY a.title, a.year

необходимо доработать. Вы получаете количество треков по каждому альбому, что неверно. Согласно условию задания, необходимо получить общее количество треков альбомов, которые выпущены в определенных годах. Т.е. здесь не нужна группировка и не нужно получение дополнительных данных. На консоль выводится только общее количество треков. Пример реализации ниже


SELECT COUNT(...) FROM ... /* Количество айди треков из таблицы треков */

JOIN ... ON ... = ... /* Делаем объединение от таблицы треков к альбомам */

WHERE ... BETWEEN ... and ...; /* Где год альбома находится в требуемом промежутке */


1. Данный запрос

-- 3.4 выведем всех исполнителей, которые не выпустили альбомы в 2020 году.

SELECT ar.name, al.year FROM artist ar

JOIN artistalbum aa ON ar.id = aa.artist_id

JOIN album al ON aa.album_id = al.id

WHERE al.year != 2020


реализован не совсем корректно. Согласно условию, в выборку не должны попасть исполнители, у которых есть альбомы, выпущенные в 20-м году. Т.е. если у исполнителя, например, есть два альбома, один из которых выпущен в 20-м году, а другой в любом другом, то такой исполнитель не должен попасть в выборку. Данный запрос реализуется через вложенный запрос, где получаем исполнителей, которые выпустили альбомы в 20-м году, а потом выводим тех, кто не попадает в этот список. Пример реализации ниже


SELECT ... /* Получаем имена исполнителей */

FROM ...  /* Из таблицы исполнителей */

WHERE ... NOT IN ( /* Где имя исполнителя не входит в вложенную выборку */

    SELECT ... /* Получаем имена исполнителей */

    FROM ... /* Из таблицы исполнителей */

    JOIN ... ON ... = ... /* Объединяем с промежуточной таблицей */

    JOIN ... ON ... = ... /* Объединяем с таблицей альбомов */

    WHERE ... = ... /* Где год альбома равен 2020 */

);


1. Данный запрос.

-- 4.1 выведем названия альбомов, в которых присутствуют исполнители более чем одного жанра.

SELECT a.title FROM album a 

JOIN artistalbum aa ON a.id = aa.album_id 

JOIN artist ar ON aa.artist_id = ar.id 

JOIN artistgenre ag ON ar.id = ag.artist_id 

JOIN genre gr ON ag.genre_id = gr.id 

GROUP BY a.title 

HAVING COUNT(DISTINCT gr.id) > 1;


необходимо немного доработать. Здесь требуется дополнительная группировка по айди исполнителей из промежуточной таблицы между исполнителями и жанрами. Если группировать только по альбомам, то результат получается не точным. Например, у альбома может быть два исполнителя, у одного из которых два жанра, а у второго один. По итогу у вас получится всего 3 жанра. Чтобы получить количество жанров по одному исполнителю, то необходимо дополнительно группировать по айди исполнителей.

---
### Прежде чем отправлять работу на проверку, запустите последовательно все запросы и проверьте нет ли ошибок